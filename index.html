<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PNG-to-RGB565-Indexed-Header</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/rgbquant@1.1.2/src/rgbquant.min.js"></script>
</head>
<body class="bg-slate-950 min-h-screen flex items-center justify-center p-4 text-slate-200 font-sans">

    <div class="max-w-md w-full bg-slate-900 rounded-2xl shadow-2xl border border-slate-800 overflow-hidden">
        <header class="p-5 border-b border-slate-800 flex justify-between items-center bg-slate-900/50">
            <div>
                <h1 class="text-xl font-black text-indigo-400 tracking-tighter">PNG-to-RGB565-Indexed-Header</h1>
                <p id="status-text" class="text-[10px] text-slate-500 font-bold uppercase tracking-widest">Awaiting Image...</p>
            </div>
            <div id="alpha-badge" class="hidden px-2 py-0.5 rounded bg-pink-500/10 text-pink-400 text-[9px] font-bold border border-pink-500/20 uppercase">Alpha-Keyed</div>
        </header>

        <div id="drop-zone" class="relative group cursor-pointer text-center p-8 transition-all hover:bg-slate-800/50">
            <input type="file" id="file-input" accept="image/*" class="hidden">
            <div id="drop-content" class="space-y-3 py-4">
                <div class="w-10 h-10 bg-slate-800 text-indigo-400 rounded-full flex items-center justify-center mx-auto group-hover:scale-110 transition-transform">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-5 h-5"><path d="M12 4.5v15m7.5-7.5h-15" /></svg>
                </div>
                <p class="text-sm font-bold text-slate-400 uppercase">Drop PNG/JPG</p>
            </div>
            <canvas id="preview-canvas" class="hidden mx-auto rounded border border-slate-700 max-h-48 shadow-inner"></canvas>
        </div>

        <div id="info-bar" class="hidden px-5 py-2.5 bg-slate-950/50 border-y border-slate-800 flex justify-between items-center text-[10px] font-mono">
            <div class="flex gap-3 text-slate-500">
                <span>W: <b id="info-w" class="text-slate-200">-</b></span>
                <span>H: <b id="info-h" class="text-slate-200">-</b></span>
            </div>
            <div>
                <span id="info-colors" class="text-indigo-400 font-bold">-</span> <span class="text-slate-600">COLORS</span>
            </div>
        </div>

        <div id="result-area" class="hidden p-5 bg-slate-900">
            <div class="grid grid-cols-2 gap-3">
                <button id="copy-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white text-[11px] font-bold py-3.5 rounded-lg transition-all uppercase tracking-wider">Copy Code</button>
                <button id="download-btn" class="bg-slate-800 hover:bg-slate-700 text-white text-[11px] font-bold py-3.5 rounded-lg transition-all uppercase tracking-wider">Download .h</button>
            </div>
        </div>
        
        <div id="warn-msg" class="hidden px-5 py-2 bg-amber-500/10 text-amber-500 text-[9px] font-bold text-center border-t border-amber-500/10 uppercase tracking-widest">
             Image Quantized to fit 8-bit limit
        </div>
    </div>

    <script>
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const statusText = document.getElementById('status-text');
        const previewCanvas = document.getElementById('preview-canvas');
        const infoBar = document.getElementById('info-bar');
        const resultArea = document.getElementById('result-area');
        const warnMsg = document.getElementById('warn-msg');
        const alphaBadge = document.getElementById('alpha-badge');
        
        let finalHeader = "";

        dropZone.onclick = () => fileInput.click();
        fileInput.onchange = (e) => handleFile(e.target.files[0]);
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(n => dropZone.addEventListener(n, e => { e.preventDefault(); e.stopPropagation(); }));
        dropZone.ondrop = (e) => handleFile(e.dataTransfer.files[0]);

        function handleFile(file) {
            if (!file) return;
            const img = new Image();
            img.onload = () => processImage(img);
            img.src = URL.createObjectURL(file);
        }

        async function processImage(img) {
            statusText.innerText = "Processing...";
            warnMsg.classList.add('hidden');
            alphaBadge.classList.add('hidden');
            
            const w = img.width;
            const h = img.height;
            previewCanvas.width = w;
            previewCanvas.height = h;
            const ctx = previewCanvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            // 1. Detect Alpha
            const imgData = ctx.getImageData(0, 0, w, h).data;
            let hasAlpha = false;
            for(let i=3; i<imgData.length; i+=4) {
                if(imgData[i] < 255) { hasAlpha = true; break; }
            }

            // 2. Set Smart Palette Limit
            // If alpha exists, we need 1 slot for the transparency key (Total 256)
            const maxColors = hasAlpha ? 255 : 256;

            if(hasAlpha) {
                alphaBadge.classList.remove('hidden');
                const buffer = ctx.getImageData(0,0,w,h);
                for(let i=0; i<buffer.data.length; i+=4) {
                    if(buffer.data[i+3] < 255) {
                        // Key transparent pixels to Pink (#FF69B4)
                        buffer.data[i]=255; buffer.data[i+1]=105; buffer.data[i+2]=180; buffer.data[i+3]=255;
                    }
                }
                ctx.putImageData(buffer, 0, 0);
            }

            document.getElementById('drop-content').classList.add('hidden');
            previewCanvas.classList.remove('hidden');
            infoBar.classList.remove('hidden');

            setTimeout(() => {
                const q = new RgbQuant({ colors: maxColors, method: 2 });
                q.sample(previewCanvas);
                let palette = q.palette(); 
                let indices = q.reduce(previewCanvas, 2); 
                let colorCount = palette.length / 4;

                // Show warning if the source had more colors than our 8-bit limit
                if (colorCount >= maxColors) warnMsg.classList.remove('hidden');

                // If alpha, manually inject the pink key as the 256th color (Index 255)
                if(hasAlpha) {
                    const newPal = new Uint8Array(256 * 4);
                    newPal.set(palette);
                    newPal[255*4]=255; newPal[255*4+1]=105; newPal[255*4+2]=180; newPal[255*4+3]=255;
                    palette = newPal;
                    colorCount = 256;
                }

                document.getElementById('info-w').innerText = w;
                document.getElementById('info-h').innerText = h;
                document.getElementById('info-colors').innerText = colorCount;

                finalHeader = generateHeader(w, h, palette, indices, colorCount, hasAlpha);
                
                resultArea.classList.remove('hidden');
                statusText.innerText = "Complete";
            }, 50);
        }

        function generateHeader(w, h, palette, indices, palCount, hasAlpha) {
            let s = `// Auto-generated 8-bit indexed graphic\n`;
            if(hasAlpha) s += `// Transparency Key: #FF69B4 (Index 255)\n`;
            s += `#ifndef SPLASH_INDEXED_H\n#define SPLASH_INDEXED_H\n\n#include <Arduino.h>\n\n`;
            s += `static constexpr uint16_t SPLASH_W = ${w};\n`;
            s += `static constexpr uint16_t SPLASH_H = ${h};\n\n`;
            
            s += `const uint8_t epd_bitmap_Splash8[] PROGMEM = {\n    `;
            for (let i = 0; i < indices.length; i++) {
                s += indices[i] + (i === indices.length - 1 ? "" : ", ");
                if ((i + 1) % 16 === 0) s += "\n    ";
            }
            s += `\n};\n\nconst uint16_t epd_palette_Splash[${palCount}] PROGMEM = {\n    `;
            for (let i = 0; i < palCount; i++) {
                const r = palette[i*4], g = palette[i*4+1], b = palette[i*4+2];
                // RGB565 conversion from your Python script
                const rgb565 = ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
                s += `0x${rgb565.toString(16).toUpperCase().padStart(4, '0')}${i === palCount - 1 ? '' : ', '}`;
                if ((i + 1) % 8 === 0) s += "\n    ";
            }
            s += `\n};\n\n#endif`;
            return s;
        }

        document.getElementById('copy-btn').onclick = () => {
            navigator.clipboard.writeText(finalHeader);
            const btn = document.getElementById('copy-btn');
            btn.innerText = "COPIED!";
            setTimeout(() => btn.innerText = "Copy Header", 1500);
        };

        document.getElementById('download-btn').onclick = () => {
            const blob = new Blob([finalHeader], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'splash_indexed.h';
            a.click();
        };
    </script>
</body>
</html>
